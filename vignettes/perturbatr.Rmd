---
title: "perturbatr cookbook"
author: "Simon Dirmeier"
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
    toc_float: true
bibliography: perturbatr.bib
vignette: >
  %\VignetteIndexEntry{perturbatr cookbook}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r style, echo=FALSE, results='asis'}
  BiocStyle::markdown()
```

```{r setup, include=FALSE}
  knitr::opts_chunk$set(echo = TRUE)
  options(warn = -1)
  library(data.table)
  library(dplyr)
  library(dtplyr)
  library(methods)
  library(perturbatr)
  data(rnaiscreen)
  my.data <- dataSet(rnaiscreen) %>%
    dplyr::filter(Condition=="V1") %>%
    dplyr::select(Condition, Replicate, GeneSymbol, Perturbation, Readout) %>%
    as.data.frame
```

# Introduction

`perturbatr` does stage-wise analysis of large-scale genetic
 perturbation screens for integrated data sets consisting of multiple screens.
 For multiple integrated perturbation screens a hierarchical model that
 considers the variance between different biological conditions is fitted.
 That means that we first estimate relative effect sizes for all genes.
 The resulting hit lists is then further extended using a network
 propagation algorithm to correct for false negatives.

# Tutorial

This tutorial walks you to the basic functionality of `perturbatr` using a pan-pathogenic data set of several RNAi screening studies.

## Creating a `PerturbationData` object

You supposedly start with something like a `data.frame` or `data.table`:

```{r, include=TRUE, size="tiny"}
  head(my.data)
```

In order to create a perturbation data set you only need to call the `as`
method:

```{r, include=TRUE, eval=TRUE}
  my.perturbation.data <- methods::as(my.data, "PerturbationData")
```

Coercing your `data.frame` to `PerturbationData` will automatically warn you if
your table is formatted wrongly. You need at least the following column names
order to be able to do analysis of perturbation screens using `perturbatr`:

* Condition: an identifier that best describes the respective screen. For instance this can be the name of a virus for pathogen screens, the name of a cell line, organoid or the like. The *condition* describes a single data set, i.e. if you want to integrate multiple different data sets, make sure to give each a different condition.
* Replicate: an integer representing the replicate number of a screen.
* GeneSymbol: the HUGO identifier, ENTREZ id, etc. as character.
* Perturbation: a siRNA id or gRNA id that describes the knockout/knockdown for the gene
* Readout: a *normalized* readout like a log-fold change for gRNAs, a GFP signal, etc.

Depending on how you want to model the readout using the hierarchical model, you might want to add additional
columns. For the sake of simplicity this suffices though.

## Working with `PerturbationData` S4 objects

A `PerturbationData` object consists of a single slot that stores your data. We
bundled your data into an `S4` object such that dispatch is easier to handle and to make sure that your data set has the correct columns:

```{r, eval=TRUE, include=TRUE}
  my.perturbation.data
  dataSet(my.perturbation.data)
```

`PerturbationData` has some basic `select`, `filter` and `rbind` functionality.
Similar to `dplyr::filter` you can select rows by some predicate(s). In the example below we extract all rows from the data set that have a positive readout.

```{r, eval=TRUE, include=TRUE}
  perturbatr::filter(my.perturbation.data, Readout > 0)
```

Filtering on multiple rows works by just adding predicates:
```{r, eval=TRUE, include=TRUE}
  perturbatr::filter(my.perturbation.data, Readout > 0, Replicate == 2)
```

If you want to combine data sets you can call `rbind`, which will automatically dispatch on `PerturbationData` object:
```{r, eval=TRUE, include=TRUE}
  dh <- perturbatr::filter(my.perturbation.data, Readout > 0, Replicate == 2)
  rbind(dh, dh)
```

Finally you can subset a set of columns just as by using `dplyr::select`. The selected columns are provided by a variable number of unquoted column names:
```{r, eval=TRUE, include=TRUE}
  perturbatr::select(my.perturbation.data, GeneSymbol, Readout)
```

Notice, that if you `select` some columns on `PerturbationData` it returns a
`tibble`. That is because, once you subset it, it is no longer guaranteed to have the required columns.

## Data analysis using a hierarchical model and network diffusion

Finally, after having set up the data set, we analyse it using a hierarchical model and network diffusion. We **expect you already normalized the data sets accordingly**. As noted above, if you want to analyse multiple data sets, make sure that every data set corresponds to a unique `Condition`.

For the sake of simplicity, you can model your readout as a linear combination of fixed effects and clustering effects for genes and genes nested in a condition:

$$y_{cgp} = x_c \beta + \gamma_g  + \delta_{cg} + \dots + y_{cgp}$$

where $y_{cgpt}$ is the phenotype for a condition $c$, gene $g$ and perturbation $p$. This would correspond to the `formula`

```{r, eval=FALSE, include=TRUE, warning=FALSE, message=FALSE}
  Readout ~ Condition + (1|GeneSymbol) + (1|Condition:GeneSymbol)
```

which is the default argument. You can see that we model the gene effect using different intercepts for each gene. To use the hierarchical model with the above formula, call:

```{r, eval=TRUE, include=TRUE, warning=FALSE, message=FALSE}
  res <- hm(my.perturbation.data, effect.size=0.01)
```

Depending on your data set different clustering effects might be present of course. So let's have a look at our data again:

```{r, include=TRUE, size="tiny"}
  dataSet(my.perturbation.data)
```

For viral perturbation screens, as simulated by our example data set, we know that viruses make use of different host factors during their life cycle. That means while some genes are required during *entry and replication*, others might play a role in *assembly and release* of the virions. So we have reason to believe that the stage of the infection also introduces a clustering effect. In that case we would need to add a random effect for the stage of the infection.

```{r, eval=TRUE, include=TRUE, warning=FALSE, message=FALSE}
  frm <- Readout ~ Condition + (1|GeneSymbol) +
                               (1|Condition:GeneSymbol) +
                               (1|ScreenType) +
                               (1|Condition:ScreenType)
  res <- hm(my.perturbation.data, formula = frm, effect.size=0.01)
```

**Note that for your own data different effects might be visible. Thus, before modelling you need to exploratorily detect possible effects.**

Let's take the last result and plot them. This yields a list of multiple plots. The most informative one that shows the top 25 genes:

```{r eval=TRUE, include=TRUE, fig.align="center", fig.width=4, warning=FALSE, message=FALSE}
  pl <- plot(res)
  print(pl[[1]])
```

Next we might want to *smooth* the effect from the hierarchical model using network diffusion, by that possibly reduce the number of some false negatives. For that we need a graph file and call the `diffuse` function. If we plot the results we get a nice visualization of the graph and newly detected hits using the diffusion. In our example we do not compute the diffusion, because loading the graph takes a lot of memory, but go ahead a try yourself:

```{r eval=FALSE, include=TRUE, fig.align="center", fig.width=4, message=FALSE}
  graph.file <- system.file("extdata", "graph_file.tsv", package = "perturbatr")
  diffu      <- diffuse(res, path=graph.file, r=0.1)
  plot(diffu)
```

## Session info

```{r eval=TRUE, include=TRUE}
  sessionInfo()
```

## References
