---
title: "Knockout cookbook"
author: "Simon Dirmeier"
date: "`r Sys.Date()`"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{Knockout cookbook}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
  knitr::opts_chunk$set(echo = TRUE)
  library(data.table)
  library(dplyr)
  library(methods)
  library(knockout)
  data(rnaiscreen)
  my.data <- rnaiscreen@.data %>% 
    dplyr::filter(Virus=="V1") %>%
    dplyr::select(Replicate, Plate, RowIdx, ColIdx, 
                  GeneSymbol, Readout, Control, siRNAIDs)
```

# Introduction

`knockout` does analysis of large-scale gene knockout/knockdown screens.
 For this several preprocessing and data normalization techniques such as
 *median-polish* or *quantile-quantile normalization* are implemented.
 On the normalized data-set essential hits can be prioritized using 
 state-of-the-art analysis tools, such as *gespeR* or *pmm*. 
 The resulting hit lists can be further extended using network diffusion 
 algorithms, such as *Markov random walks with restarts* or the well-known
 *heat equation*. Eventually hits can be analyses using *GSEA*, etc.

# Tutorial

This tutorial walks you to the basic functionality of `knockout`.

## Creating a raw data-set

You supposedly start with something like a `data.frame`. In order to create a 
`knockout-data`-set you need to transfrom it into a `data.table` with at least 
the following columns:

```{r, include=TRUE}
  print(my.data)
```

You can then use your data-set `my.data` and cast it to a `knockout.data` object:

```{r, include=TRUE, eval=TRUE}
  my.knockout.data <- methods::as(my.data, "knockout.data")
```

Coercing your `data.table` to `knockout.data` will automatically warn you if 
your table is formatted wrongly.

## Working with `knockout.data` S4 objects

For objects that inherit the abstract `knockout.data` class, we provide basic 
`select`, `filter`, `group_by` and `rbind` functionality:

```{r, eval=TRUE, include=TRUE}
  select(my.knockout.data, GeneSymbol, Readout)
  rbind(filter(my.knockout.data, Readout > 0),
        filter(my.knockout.data, Readout < 0))
```

If you want to work directly on the data-set you shoult access it on the `.data` attribute though:

```{r, eval=FALSE}
  my.knockout.data@.data
```

## Preprocessing

Raw image-based screens have usually to be normalized in order to ensure
comparability between plates. Normalization can be done using the `preprocess` 
method. We use one of the provided data-sets for this. But before we do any normalisations 
we should have a look at quality scores and single plates before:

```{r, eval=T, include=T}
  data(rnaiscreen)
```

```{r, eval=T, include=T, fig.align="center", fig.width=6}
  v1.data         <- filter(rnaiscreen, Virus == "V1")
  v1.data.quality <- quality(v1.data)
  pl              <- plot(v1.data.quality)
```

Since we know that RNAi screens often suffer from batch effects we also might want to look at single plates

```{r, eval=TRUE, include=T, fig.align="center", fig.width=6}
  plates <- plates(v1.data)
  plot(plates[1], show.gene.names=T, gene.text.size=2)
```

```{r, eval=TRUE, include=T, fig.align="center", fig.width=6}
  repls <- replicates(v1.data)
  plot(repls[1], repls[2])
```

The `preprocess` method offers a collection of common techniques to normalize 
RNAi-screening data. We just call it with the standard parameters, which takes the natural 
logarithm on every plate and afterwards computes a more robust version of the standard Z-score.

```{r, eval=TRUE, include=T}
  v1.data.norm <- knockout::preprocess(
    v1.data, normalize=c("log", "robust-z.score"))
```

The result shouldn't be too different from before since we use artificial data. But for completeness' sake let's do the full analysis. We do the same as
before (this time w/o plots, though)

```{r, eval=FALSE, include=TRUE}
  v1.data.norm.quality <- quality(v1.data.norm)
  pl <- plot(v1.data.norm.quality)

  plates <- plates(v1.data.norm)
  plot(plates[1], show.gene.names=T, gene.text.size=2)

  repls <- replicates(v1.data.norm)
  plot(repls[1], repls[2])
```

The result object has class `knockout.normalized.data` which can be used for analysis.

In the example above we just computed the log and robust Z-scores for every 
plate separately. Often, when we have for instance information of cell-counts, 
cell-viability or expect spatial effects due to several batch effects other 
normalization methods are more suitable. Furthermore when your data-set 
comprises multiple different screens, you might want to normalize every screen 
separately.

In this case you would first filter the data-set by single experiments. For our provided 
filtering by `Virus` and `Screen` results int a single experiment; 
*for your data this might be different though*.

```{r, eval=TRUE, include=T}
  v1.dat <- filter(rnaiscreen, Virus=="V1")
  v2.dat <- filter(rnaiscreen, Virus=="V2")
```

## Data-analysis


